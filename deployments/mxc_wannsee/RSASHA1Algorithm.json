{
  "address": "0xFFDcD6f4EE6f82D42576Af0590DAb6204585e56c",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "key",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "sig",
          "type": "bytes"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xcc9a4e74f87131fae6db24e845597f63f4dcfb06ace185fc8ea923858545a6cf",
  "receipt": {
    "to": null,
    "from": "0x52f60448790E485F38f2Aa9c867CD0DD647c0b73",
    "contractAddress": "0xFFDcD6f4EE6f82D42576Af0590DAb6204585e56c",
    "transactionIndex": 1,
    "gasUsed": "662944",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xfae340e0c0f08744a21bdd1a1f1123a939333637853133ae5c43f0b35ed1e5b8",
    "transactionHash": "0xcc9a4e74f87131fae6db24e845597f63f4dcfb06ace185fc8ea923858545a6cf",
    "logs": [],
    "blockNumber": 69,
    "cumulativeGasUsed": "792197",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "b0f86eb025a2bf184421368d827bdf79",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"key\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implements the DNSSEC RSASHA1 algorithm.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/dnssec-oracle/algorithms/RSASHA1Algorithm.sol\":\"RSASHA1Algorithm\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@ensdomains/solsha1/contracts/SHA1.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nlibrary SHA1 {\\n    event Debug(bytes32 x);\\n\\n    function sha1(bytes memory data) internal pure returns(bytes20 ret) {\\n        assembly {\\n            // Get a safe scratch location\\n            let scratch := mload(0x40)\\n\\n            // Get the data length, and point data at the first byte\\n            let len := mload(data)\\n            data := add(data, 32)\\n\\n            // Find the length after padding\\n            let totallen := add(and(add(len, 1), 0xFFFFFFFFFFFFFFC0), 64)\\n            switch lt(sub(totallen, len), 9)\\n            case 1 { totallen := add(totallen, 64) }\\n\\n            let h := 0x6745230100EFCDAB890098BADCFE001032547600C3D2E1F0\\n\\n            function readword(ptr, off, count) -> result {\\n                result := 0\\n                if lt(off, count) {\\n                    result := mload(add(ptr, off))\\n                    count := sub(count, off)\\n                    if lt(count, 32) {\\n                        let mask := not(sub(exp(256, sub(32, count)), 1))\\n                        result := and(result, mask)\\n                    }\\n                }\\n            }\\n\\n            for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {\\n                mstore(scratch, readword(data, i, len))\\n                mstore(add(scratch, 32), readword(data, add(i, 32), len))\\n\\n                // If we loaded the last byte, store the terminator byte\\n                switch lt(sub(len, i), 64)\\n                case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }\\n\\n                // If this is the last block, store the length\\n                switch eq(i, sub(totallen, 64))\\n                case 1 { mstore(add(scratch, 32), or(mload(add(scratch, 32)), mul(len, 8))) }\\n\\n                // Expand the 16 32-bit words into 80\\n                for { let j := 64 } lt(j, 128) { j := add(j, 12) } {\\n                    let temp := xor(xor(mload(add(scratch, sub(j, 12))), mload(add(scratch, sub(j, 32)))), xor(mload(add(scratch, sub(j, 56))), mload(add(scratch, sub(j, 64)))))\\n                    temp := or(and(mul(temp, 2), 0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE), and(div(temp, 0x80000000), 0x0000000100000001000000010000000100000001000000010000000100000001))\\n                    mstore(add(scratch, j), temp)\\n                }\\n                for { let j := 128 } lt(j, 320) { j := add(j, 24) } {\\n                    let temp := xor(xor(mload(add(scratch, sub(j, 24))), mload(add(scratch, sub(j, 64)))), xor(mload(add(scratch, sub(j, 112))), mload(add(scratch, sub(j, 128)))))\\n                    temp := or(and(mul(temp, 4), 0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC), and(div(temp, 0x40000000), 0x0000000300000003000000030000000300000003000000030000000300000003))\\n                    mstore(add(scratch, j), temp)\\n                }\\n\\n                let x := h\\n                let f := 0\\n                let k := 0\\n                for { let j := 0 } lt(j, 80) { j := add(j, 1) } {\\n                    switch div(j, 20)\\n                    case 0 {\\n                        // f = d xor (b and (c xor d))\\n                        f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))\\n                        f := and(div(x, 0x1000000000000000000000000000000), f)\\n                        f := xor(div(x, 0x10000000000), f)\\n                        k := 0x5A827999\\n                    }\\n                    case 1{\\n                        // f = b xor c xor d\\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\\n                        f := xor(div(x, 0x10000000000), f)\\n                        k := 0x6ED9EBA1\\n                    }\\n                    case 2 {\\n                        // f = (b and c) or (d and (b or c))\\n                        f := or(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\\n                        f := and(div(x, 0x10000000000), f)\\n                        f := or(and(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000)), f)\\n                        k := 0x8F1BBCDC\\n                    }\\n                    case 3 {\\n                        // f = b xor c xor d\\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\\n                        f := xor(div(x, 0x10000000000), f)\\n                        k := 0xCA62C1D6\\n                    }\\n                    // temp = (a leftrotate 5) + f + e + k + w[i]\\n                    let temp := and(div(x, 0x80000000000000000000000000000000000000000000000), 0x1F)\\n                    temp := or(and(div(x, 0x800000000000000000000000000000000000000), 0xFFFFFFE0), temp)\\n                    temp := add(f, temp)\\n                    temp := add(and(x, 0xFFFFFFFF), temp)\\n                    temp := add(k, temp)\\n                    temp := add(div(mload(add(scratch, mul(j, 4))), 0x100000000000000000000000000000000000000000000000000000000), temp)\\n                    x := or(div(x, 0x10000000000), mul(temp, 0x10000000000000000000000000000000000000000))\\n                    x := or(and(x, 0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF), mul(or(and(div(x, 0x4000000000000), 0xC0000000), and(div(x, 0x400000000000000000000), 0x3FFFFFFF)), 0x100000000000000000000))\\n                }\\n\\n                h := and(add(h, x), 0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF)\\n            }\\n            ret := mul(or(or(or(or(and(div(h, 0x100000000), 0xFFFFFFFF00000000000000000000000000000000), and(div(h, 0x1000000), 0xFFFFFFFF000000000000000000000000)), and(div(h, 0x10000), 0xFFFFFFFF0000000000000000)), and(div(h, 0x100), 0xFFFFFFFF00000000)), and(h, 0xFFFFFFFF)), 0x1000000000000000000000000)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x746d9b85de197afbc13182cbe4ba4f7917f19594e07c655d6a0c85fdf7460a8a\"},\"contracts/dnssec-oracle/BytesUtils.sol\":{\"content\":\"pragma solidity ^0.8.4;\\r\\n\\r\\nlibrary BytesUtils {\\r\\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the keccak-256 hash of a byte range.\\r\\n     * @param self The byte string to hash.\\r\\n     * @param offset The position to start hashing at.\\r\\n     * @param len The number of bytes to hash.\\r\\n     * @return The hash of the byte range.\\r\\n     */\\r\\n    function keccak(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32 ret) {\\r\\n        require(offset + len <= self.length);\\r\\n        assembly {\\r\\n            ret := keccak256(add(add(self, 32), offset), len)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns a positive number if `other` comes lexicographically after\\r\\n     *      `self`, a negative number if it comes before, or zero if the\\r\\n     *      contents of the two bytes are equal.\\r\\n     * @param self The first bytes to compare.\\r\\n     * @param other The second bytes to compare.\\r\\n     * @return The result of the comparison.\\r\\n     */\\r\\n    function compare(\\r\\n        bytes memory self,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (int256) {\\r\\n        return compare(self, 0, self.length, other, 0, other.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns a positive number if `other` comes lexicographically after\\r\\n     *      `self`, a negative number if it comes before, or zero if the\\r\\n     *      contents of the two bytes are equal. Comparison is done per-rune,\\r\\n     *      on unicode codepoints.\\r\\n     * @param self The first bytes to compare.\\r\\n     * @param offset The offset of self.\\r\\n     * @param len    The length of self.\\r\\n     * @param other The second bytes to compare.\\r\\n     * @param otheroffset The offset of the other string.\\r\\n     * @param otherlen    The length of the other string.\\r\\n     * @return The result of the comparison.\\r\\n     */\\r\\n    function compare(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len,\\r\\n        bytes memory other,\\r\\n        uint256 otheroffset,\\r\\n        uint256 otherlen\\r\\n    ) internal pure returns (int256) {\\r\\n        if (offset + len > self.length) {\\r\\n            revert OffsetOutOfBoundsError(offset + len, self.length);\\r\\n        }\\r\\n        if (otheroffset + otherlen > other.length) {\\r\\n            revert OffsetOutOfBoundsError(otheroffset + otherlen, other.length);\\r\\n        }\\r\\n\\r\\n        uint256 shortest = len;\\r\\n        if (otherlen < len) shortest = otherlen;\\r\\n\\r\\n        uint256 selfptr;\\r\\n        uint256 otherptr;\\r\\n\\r\\n        assembly {\\r\\n            selfptr := add(self, add(offset, 32))\\r\\n            otherptr := add(other, add(otheroffset, 32))\\r\\n        }\\r\\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\\r\\n            uint256 a;\\r\\n            uint256 b;\\r\\n            assembly {\\r\\n                a := mload(selfptr)\\r\\n                b := mload(otherptr)\\r\\n            }\\r\\n            if (a != b) {\\r\\n                // Mask out irrelevant bytes and check again\\r\\n                uint256 mask;\\r\\n                if (shortest - idx >= 32) {\\r\\n                    mask = type(uint256).max;\\r\\n                } else {\\r\\n                    mask = ~(2 ** (8 * (idx + 32 - shortest)) - 1);\\r\\n                }\\r\\n                int256 diff = int256(a & mask) - int256(b & mask);\\r\\n                if (diff != 0) return diff;\\r\\n            }\\r\\n            selfptr += 32;\\r\\n            otherptr += 32;\\r\\n        }\\r\\n\\r\\n        return int256(len) - int256(otherlen);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @param otherOffset The offset into the second byte range.\\r\\n     * @param len The number of bytes to compare\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other,\\r\\n        uint256 otherOffset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bool) {\\r\\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal with offsets.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @param otherOffset The offset into the second byte range.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other,\\r\\n        uint256 otherOffset\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            keccak(self, offset, self.length - offset) ==\\r\\n            keccak(other, otherOffset, other.length - otherOffset);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Compares a range of 'self' to all of 'other' and returns True iff\\r\\n     *      they are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param offset The offset into the first byte range.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            self.length == offset + other.length &&\\r\\n            equals(self, offset, other, 0, other.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns true if the two byte ranges are equal.\\r\\n     * @param self The first byte range to compare.\\r\\n     * @param other The second byte range to compare.\\r\\n     * @return True if the byte ranges are equal, false otherwise.\\r\\n     */\\r\\n    function equals(\\r\\n        bytes memory self,\\r\\n        bytes memory other\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            self.length == other.length &&\\r\\n            equals(self, 0, other, 0, self.length);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 8-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 8 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint8(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (uint8 ret) {\\r\\n        return uint8(self[idx]);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 16-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 16 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint16(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (uint16 ret) {\\r\\n        require(idx + 2 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32-bit number at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bits of the string, interpreted as an integer.\\r\\n     */\\r\\n    function readUint32(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (uint32 ret) {\\r\\n        require(idx + 4 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32 byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytes32(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (bytes32 ret) {\\r\\n        require(idx + 32 <= self.length);\\r\\n        assembly {\\r\\n            ret := mload(add(add(self, 32), idx))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the 32 byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytes20(\\r\\n        bytes memory self,\\r\\n        uint256 idx\\r\\n    ) internal pure returns (bytes20 ret) {\\r\\n        require(idx + 20 <= self.length);\\r\\n        assembly {\\r\\n            ret := and(\\r\\n                mload(add(add(self, 32), idx)),\\r\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Returns the n byte value at the specified index of self.\\r\\n     * @param self The byte string.\\r\\n     * @param idx The index into the bytes.\\r\\n     * @param len The number of bytes.\\r\\n     * @return The specified 32 bytes of the string.\\r\\n     */\\r\\n    function readBytesN(\\r\\n        bytes memory self,\\r\\n        uint256 idx,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32 ret) {\\r\\n        require(len <= 32);\\r\\n        require(idx + len <= self.length);\\r\\n        assembly {\\r\\n            let mask := not(sub(exp(256, sub(32, len)), 1))\\r\\n            ret := and(mload(add(add(self, 32), idx)), mask)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\\r\\n        // Copy word-length chunks while possible\\r\\n        for (; len >= 32; len -= 32) {\\r\\n            assembly {\\r\\n                mstore(dest, mload(src))\\r\\n            }\\r\\n            dest += 32;\\r\\n            src += 32;\\r\\n        }\\r\\n\\r\\n        // Copy remaining bytes\\r\\n        unchecked {\\r\\n            uint256 mask = (256 ** (32 - len)) - 1;\\r\\n            assembly {\\r\\n                let srcpart := and(mload(src), not(mask))\\r\\n                let destpart := and(mload(dest), mask)\\r\\n                mstore(dest, or(destpart, srcpart))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @dev Copies a substring into a new byte string.\\r\\n     * @param self The byte string to copy from.\\r\\n     * @param offset The offset to start copying at.\\r\\n     * @param len The number of bytes to copy.\\r\\n     */\\r\\n    function substring(\\r\\n        bytes memory self,\\r\\n        uint256 offset,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        require(offset + len <= self.length);\\r\\n\\r\\n        bytes memory ret = new bytes(len);\\r\\n        uint256 dest;\\r\\n        uint256 src;\\r\\n\\r\\n        assembly {\\r\\n            dest := add(ret, 32)\\r\\n            src := add(add(self, 32), offset)\\r\\n        }\\r\\n        memcpy(dest, src, len);\\r\\n\\r\\n        return ret;\\r\\n    }\\r\\n\\r\\n    // Maps characters from 0x30 to 0x7A to their base32 values.\\r\\n    // 0xFF represents invalid characters in that range.\\r\\n    bytes constant base32HexTable =\\r\\n        hex\\\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\\\";\\r\\n\\r\\n    /**\\r\\n     * @dev Decodes unpadded base32 data of up to one word in length.\\r\\n     * @param self The data to decode.\\r\\n     * @param off Offset into the string to start at.\\r\\n     * @param len Number of characters to decode.\\r\\n     * @return The decoded data, left aligned.\\r\\n     */\\r\\n    function base32HexDecodeWord(\\r\\n        bytes memory self,\\r\\n        uint256 off,\\r\\n        uint256 len\\r\\n    ) internal pure returns (bytes32) {\\r\\n        require(len <= 52);\\r\\n\\r\\n        uint256 ret = 0;\\r\\n        uint8 decoded;\\r\\n        for (uint256 i = 0; i < len; i++) {\\r\\n            bytes1 char = self[off + i];\\r\\n            require(char >= 0x30 && char <= 0x7A);\\r\\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\\r\\n            require(decoded <= 0x20);\\r\\n            if (i == len - 1) {\\r\\n                break;\\r\\n            }\\r\\n            ret = (ret << 5) | decoded;\\r\\n        }\\r\\n\\r\\n        uint256 bitlen = len * 5;\\r\\n        if (len % 8 == 0) {\\r\\n            // Multiple of 8 characters, no padding\\r\\n            ret = (ret << 5) | decoded;\\r\\n        } else if (len % 8 == 2) {\\r\\n            // Two extra characters - 1 byte\\r\\n            ret = (ret << 3) | (decoded >> 2);\\r\\n            bitlen -= 2;\\r\\n        } else if (len % 8 == 4) {\\r\\n            // Four extra characters - 2 bytes\\r\\n            ret = (ret << 1) | (decoded >> 4);\\r\\n            bitlen -= 4;\\r\\n        } else if (len % 8 == 5) {\\r\\n            // Five extra characters - 3 bytes\\r\\n            ret = (ret << 4) | (decoded >> 1);\\r\\n            bitlen -= 1;\\r\\n        } else if (len % 8 == 7) {\\r\\n            // Seven extra characters - 4 bytes\\r\\n            ret = (ret << 2) | (decoded >> 3);\\r\\n            bitlen -= 3;\\r\\n        } else {\\r\\n            revert();\\r\\n        }\\r\\n\\r\\n        return bytes32(ret << (256 - bitlen));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Finds the first occurrence of the byte `needle` in `self`.\\r\\n     * @param self The string to search\\r\\n     * @param off The offset to start searching at\\r\\n     * @param len The number of bytes to search\\r\\n     * @param needle The byte to search for\\r\\n     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\\r\\n     */\\r\\n    function find(\\r\\n        bytes memory self,\\r\\n        uint256 off,\\r\\n        uint256 len,\\r\\n        bytes1 needle\\r\\n    ) internal pure returns (uint256) {\\r\\n        for (uint256 idx = off; idx < off + len; idx++) {\\r\\n            if (self[idx] == needle) {\\r\\n                return idx;\\r\\n            }\\r\\n        }\\r\\n        return type(uint256).max;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xb464edb8f5dc9369cb1ab2cb1c8af5e217d2fe11b32ef7288e37e2838b89dc59\"},\"contracts/dnssec-oracle/algorithms/Algorithm.sol\":{\"content\":\"pragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev An interface for contracts implementing a DNSSEC (signing) algorithm.\\r\\n */\\r\\ninterface Algorithm {\\r\\n    /**\\r\\n     * @dev Verifies a signature.\\r\\n     * @param key The public key to verify with.\\r\\n     * @param data The signed data to verify.\\r\\n     * @param signature The signature to verify.\\r\\n     * @return True iff the signature is valid.\\r\\n     */\\r\\n    function verify(\\r\\n        bytes calldata key,\\r\\n        bytes calldata data,\\r\\n        bytes calldata signature\\r\\n    ) external view virtual returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0x244a3d2e6290b47d2f0097c7562073180cbbcb095eea071652cf34effe918da0\"},\"contracts/dnssec-oracle/algorithms/ModexpPrecompile.sol\":{\"content\":\"pragma solidity ^0.8.4;\\r\\n\\r\\nlibrary ModexpPrecompile {\\r\\n    /**\\r\\n     * @dev Computes (base ^ exponent) % modulus over big numbers.\\r\\n     */\\r\\n    function modexp(\\r\\n        bytes memory base,\\r\\n        bytes memory exponent,\\r\\n        bytes memory modulus\\r\\n    ) internal view returns (bool success, bytes memory output) {\\r\\n        bytes memory input = abi.encodePacked(\\r\\n            uint256(base.length),\\r\\n            uint256(exponent.length),\\r\\n            uint256(modulus.length),\\r\\n            base,\\r\\n            exponent,\\r\\n            modulus\\r\\n        );\\r\\n\\r\\n        output = new bytes(modulus.length);\\r\\n\\r\\n        assembly {\\r\\n            success := staticcall(\\r\\n                gas(),\\r\\n                5,\\r\\n                add(input, 32),\\r\\n                mload(input),\\r\\n                add(output, 32),\\r\\n                mload(modulus)\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x846d22fe609832f93662baf570ea8b1cdab84dbee1409e6b927682af908df0e8\"},\"contracts/dnssec-oracle/algorithms/RSASHA1Algorithm.sol\":{\"content\":\"pragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./Algorithm.sol\\\";\\r\\nimport \\\"../BytesUtils.sol\\\";\\r\\nimport \\\"./RSAVerify.sol\\\";\\r\\nimport \\\"@ensdomains/solsha1/contracts/SHA1.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implements the DNSSEC RSASHA1 algorithm.\\r\\n */\\r\\ncontract RSASHA1Algorithm is Algorithm {\\r\\n    using BytesUtils for *;\\r\\n\\r\\n    function verify(\\r\\n        bytes calldata key,\\r\\n        bytes calldata data,\\r\\n        bytes calldata sig\\r\\n    ) external view override returns (bool) {\\r\\n        bytes memory exponent;\\r\\n        bytes memory modulus;\\r\\n\\r\\n        uint16 exponentLen = uint16(key.readUint8(4));\\r\\n        if (exponentLen != 0) {\\r\\n            exponent = key.substring(5, exponentLen);\\r\\n            modulus = key.substring(\\r\\n                exponentLen + 5,\\r\\n                key.length - exponentLen - 5\\r\\n            );\\r\\n        } else {\\r\\n            exponentLen = key.readUint16(5);\\r\\n            exponent = key.substring(7, exponentLen);\\r\\n            modulus = key.substring(\\r\\n                exponentLen + 7,\\r\\n                key.length - exponentLen - 7\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // Recover the message from the signature\\r\\n        bool ok;\\r\\n        bytes memory result;\\r\\n        (ok, result) = RSAVerify.rsarecover(modulus, exponent, sig);\\r\\n\\r\\n        // Verify it ends with the hash of our data\\r\\n        return ok && SHA1.sha1(data) == result.readBytes20(result.length - 20);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x429f94cf197aa5f96b1127b64e71089cbff08d3396f1e1b38b1d3fa7e6cc0048\"},\"contracts/dnssec-oracle/algorithms/RSAVerify.sol\":{\"content\":\"pragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"../BytesUtils.sol\\\";\\r\\nimport \\\"./ModexpPrecompile.sol\\\";\\r\\n\\r\\nlibrary RSAVerify {\\r\\n    /**\\r\\n     * @dev Recovers the input data from an RSA signature, returning the result in S.\\r\\n     * @param N The RSA public modulus.\\r\\n     * @param E The RSA public exponent.\\r\\n     * @param S The signature to recover.\\r\\n     * @return True if the recovery succeeded.\\r\\n     */\\r\\n    function rsarecover(\\r\\n        bytes memory N,\\r\\n        bytes memory E,\\r\\n        bytes memory S\\r\\n    ) internal view returns (bool, bytes memory) {\\r\\n        return ModexpPrecompile.modexp(S, E, N);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x0f21c9e8e52827e059eaab2c644ceb5b03e89c5683fcab9d75916b9bfdec17fe\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610b0b806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063de8f50a114610030575b600080fd5b61004361003e366004610945565b610057565b604051901515815260200160405180910390f35b600060608060006100a260048b8b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092939250506103009050565b60ff169050801561016e576100f760058261ffff168c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294939250506103259050565b92506101676101078260056109f5565b61ffff9081169060059061011d9085168d610a17565b6101279190610a17565b8c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294939250506103259050565b9150610227565b6101b260058b8b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092939250506103a99050565b90506101fe60078261ffff168c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294939250506103259050565b925061022461020e8260076109f5565b61ffff9081169060079061011d9085168d610a17565b91505b6000606061026c84868a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506103d192505050565b90925090508180156102f057506102916014825161028a9190610a17565b82906103ec565b6bffffffffffffffffffffffff19166102df8b8b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061041f92505050565b6bffffffffffffffffffffffff1916145b9c9b505050505050505050505050565b600082828151811061031457610314610a2a565b016020015160f81c90505b92915050565b82516060906103348385610a40565b111561033f57600080fd5b60008267ffffffffffffffff81111561035a5761035a610a53565b6040519080825280601f01601f191660200182016040528015610384576020820181803683370190505b5090506020808201908686010161039c82828761080f565b50909150505b9392505050565b81516000906103b9836002610a40565b11156103c457600080fd5b50016002015161ffff1690565b600060606103e0838587610865565b91509150935093915050565b81516000906103fc836014610a40565b111561040757600080fd5b5001602001516bffffffffffffffffffffffff191690565b60006040518251602084019350604067ffffffffffffffc060018301160160098282031060018103610452576040820191505b50776745230100efcdab890098badcfe001032547600c3d2e1f06104a4565b6000838310156103a2575080820151928290039260208410156103a25760001960208590036101000a0119169392505050565b60005b828110156107ae576104ba848289610471565b85526104ca846020830189610471565b6020860152604081850310600181036104e65760808286038701535b506040830381146001810361050357602086018051600887021790525b5060405b608081101561058b57858101603f19810151603719820151601f19830151600b198401516002911891909218189081027ffffffffefffffffefffffffefffffffefffffffefffffffefffffffefffffffe1663800000009091047c010000000100000001000000010000000100000001000000010000000116179052600c01610507565b5060805b61014081101561061457858101607f19810151606f19820151603f198301516017198401516004911891909218189081027ffffffffcfffffffcfffffffcfffffffcfffffffcfffffffcfffffffcfffffffc1663400000009091047c03000000030000000300000003000000030000000300000003000000031617905260180161058f565b508160008060005b60508110156107845760148104801561064c5760018114610673576002811461069857600381146106c2576106e3565b600160281b8504600160501b86048118600160781b870416189350635a82799992506106e3565b600160281b8504600160781b8604600160501b870418189350636ed9eba192506106e3565b600160501b8504600160781b8604818117600160281b8804169116179350638f1bbcdc92506106e3565b600160281b8504600160781b8604600160501b87041818935063ca62c1d692505b50601f600160bb1b8504168063ffffffe06001609b1b87041617905080840190508063ffffffff8616019050808301905080600160e01b600484028c015104019050600160a01b8102600160281b860417945050600160501b633fffffff600160521b86041663c00000006604000000000000870416170277ffffffff00ffffffff000000000000ffffffff00ffffffff851617935060018101905061061c565b5050509190910177ffffffff00ffffffff00ffffffff00ffffffff00ffffffff16906040016104a7565b50600160601b63ffffffff821667ffffffff000000006101008404166bffffffff00000000000000006201000085041663ffffffff60601b630100000086041663ffffffff60801b6401000000008704161717171702945050505050919050565b602081106108475781518352610826602084610a40565b9250610833602083610a40565b9150610840602082610a17565b905061080f565b905182516020929092036101000a6000190180199091169116179052565b60006060600085518551855188888860405160200161088996959493929190610a99565b6040516020818303038152906040529050835167ffffffffffffffff8111156108b4576108b4610a53565b6040519080825280601f01601f1916602001820160405280156108de576020820181803683370190505b50915083516020830182516020840160055afa925050935093915050565b60008083601f84011261090e57600080fd5b50813567ffffffffffffffff81111561092657600080fd5b60208301915083602082850101111561093e57600080fd5b9250929050565b6000806000806000806060878903121561095e57600080fd5b863567ffffffffffffffff8082111561097657600080fd5b6109828a838b016108fc565b9098509650602089013591508082111561099b57600080fd5b6109a78a838b016108fc565b909650945060408901359150808211156109c057600080fd5b506109cd89828a016108fc565b979a9699509497509295939492505050565b634e487b7160e01b600052601160045260246000fd5b61ffff818116838216019080821115610a1057610a106109df565b5092915050565b8181038181111561031f5761031f6109df565b634e487b7160e01b600052603260045260246000fd5b8082018082111561031f5761031f6109df565b634e487b7160e01b600052604160045260246000fd5b6000815160005b81811015610a8a5760208185018101518683015201610a70565b50600093019283525090919050565b8681528560208201528460408201526000610ac9610ac3610abd6060850188610a69565b86610a69565b84610a69565b9897505050505050505056fea26469706673582212202100de2c7fd2de953658bad97e4bd5d208bf08d1533b198bd97b65cdc73610f664736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063de8f50a114610030575b600080fd5b61004361003e366004610945565b610057565b604051901515815260200160405180910390f35b600060608060006100a260048b8b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092939250506103009050565b60ff169050801561016e576100f760058261ffff168c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294939250506103259050565b92506101676101078260056109f5565b61ffff9081169060059061011d9085168d610a17565b6101279190610a17565b8c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294939250506103259050565b9150610227565b6101b260058b8b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525092939250506103a99050565b90506101fe60078261ffff168c8c8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509294939250506103259050565b925061022461020e8260076109f5565b61ffff9081169060079061011d9085168d610a17565b91505b6000606061026c84868a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506103d192505050565b90925090508180156102f057506102916014825161028a9190610a17565b82906103ec565b6bffffffffffffffffffffffff19166102df8b8b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061041f92505050565b6bffffffffffffffffffffffff1916145b9c9b505050505050505050505050565b600082828151811061031457610314610a2a565b016020015160f81c90505b92915050565b82516060906103348385610a40565b111561033f57600080fd5b60008267ffffffffffffffff81111561035a5761035a610a53565b6040519080825280601f01601f191660200182016040528015610384576020820181803683370190505b5090506020808201908686010161039c82828761080f565b50909150505b9392505050565b81516000906103b9836002610a40565b11156103c457600080fd5b50016002015161ffff1690565b600060606103e0838587610865565b91509150935093915050565b81516000906103fc836014610a40565b111561040757600080fd5b5001602001516bffffffffffffffffffffffff191690565b60006040518251602084019350604067ffffffffffffffc060018301160160098282031060018103610452576040820191505b50776745230100efcdab890098badcfe001032547600c3d2e1f06104a4565b6000838310156103a2575080820151928290039260208410156103a25760001960208590036101000a0119169392505050565b60005b828110156107ae576104ba848289610471565b85526104ca846020830189610471565b6020860152604081850310600181036104e65760808286038701535b506040830381146001810361050357602086018051600887021790525b5060405b608081101561058b57858101603f19810151603719820151601f19830151600b198401516002911891909218189081027ffffffffefffffffefffffffefffffffefffffffefffffffefffffffefffffffe1663800000009091047c010000000100000001000000010000000100000001000000010000000116179052600c01610507565b5060805b61014081101561061457858101607f19810151606f19820151603f198301516017198401516004911891909218189081027ffffffffcfffffffcfffffffcfffffffcfffffffcfffffffcfffffffcfffffffc1663400000009091047c03000000030000000300000003000000030000000300000003000000031617905260180161058f565b508160008060005b60508110156107845760148104801561064c5760018114610673576002811461069857600381146106c2576106e3565b600160281b8504600160501b86048118600160781b870416189350635a82799992506106e3565b600160281b8504600160781b8604600160501b870418189350636ed9eba192506106e3565b600160501b8504600160781b8604818117600160281b8804169116179350638f1bbcdc92506106e3565b600160281b8504600160781b8604600160501b87041818935063ca62c1d692505b50601f600160bb1b8504168063ffffffe06001609b1b87041617905080840190508063ffffffff8616019050808301905080600160e01b600484028c015104019050600160a01b8102600160281b860417945050600160501b633fffffff600160521b86041663c00000006604000000000000870416170277ffffffff00ffffffff000000000000ffffffff00ffffffff851617935060018101905061061c565b5050509190910177ffffffff00ffffffff00ffffffff00ffffffff00ffffffff16906040016104a7565b50600160601b63ffffffff821667ffffffff000000006101008404166bffffffff00000000000000006201000085041663ffffffff60601b630100000086041663ffffffff60801b6401000000008704161717171702945050505050919050565b602081106108475781518352610826602084610a40565b9250610833602083610a40565b9150610840602082610a17565b905061080f565b905182516020929092036101000a6000190180199091169116179052565b60006060600085518551855188888860405160200161088996959493929190610a99565b6040516020818303038152906040529050835167ffffffffffffffff8111156108b4576108b4610a53565b6040519080825280601f01601f1916602001820160405280156108de576020820181803683370190505b50915083516020830182516020840160055afa925050935093915050565b60008083601f84011261090e57600080fd5b50813567ffffffffffffffff81111561092657600080fd5b60208301915083602082850101111561093e57600080fd5b9250929050565b6000806000806000806060878903121561095e57600080fd5b863567ffffffffffffffff8082111561097657600080fd5b6109828a838b016108fc565b9098509650602089013591508082111561099b57600080fd5b6109a78a838b016108fc565b909650945060408901359150808211156109c057600080fd5b506109cd89828a016108fc565b979a9699509497509295939492505050565b634e487b7160e01b600052601160045260246000fd5b61ffff818116838216019080821115610a1057610a106109df565b5092915050565b8181038181111561031f5761031f6109df565b634e487b7160e01b600052603260045260246000fd5b8082018082111561031f5761031f6109df565b634e487b7160e01b600052604160045260246000fd5b6000815160005b81811015610a8a5760208185018101518683015201610a70565b50600093019283525090919050565b8681528560208201528460408201526000610ac9610ac3610abd6060850188610a69565b86610a69565b84610a69565b9897505050505050505056fea26469706673582212202100de2c7fd2de953658bad97e4bd5d208bf08d1533b198bd97b65cdc73610f664736f6c63430008110033",
  "devdoc": {
    "details": "Implements the DNSSEC RSASHA1 algorithm.",
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}